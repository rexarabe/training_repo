9.21 Firewalls
Routers in particular should always include some kind of firewall to keep underisable traffic out of your network.
A firewall is a software and /or hardware configuration that usually sits on a router between the Internet and a smaller network, attempting to ensure that nothing "bad" from the Internet and a smaller network, attempting to ensure that nothing "bad" from Internet harms the smaller network.
You can also set up firewall features for each machine where the machine screens all of its incoming and outgoing data at the packet level (as opposed to the application layer, where server programs usually try to perform some access control of their own).
Firewalling on individual machines is something called IP filtering.
A system can filter packets when it
* receives a packet,
*sends a packet, or,
*forwards (routes) a packet to another host or gateway.

With no firewalling in place, a system just processes packets and sends them on their way.
Firewalls put checkpoints for packets at the points of data transfer identified above.
The checkpoint drop, reject, or accept packets, usually based on some of these criteria:

*The source or destination IP address or subnet
*The source or destination port (in the tranport layer information)
*The firewall's network interface.

Firewalls provide an ooportunity to work with the subsystem of the Linux kernel that processes IP packets.
Let's look at that now.

9.21.1 Linux Firewall Basics
In Linux, you create firewall rules in a series known as a chain.
A set of chains makes up a table.
As a packet moves through the various parts of the Linux networking subsystem, the kernel applies the rules in certain chains to the packets.
For example, after receiving a new packet from the physical layer, the kernel activates rules in chains corresponding to input.
All of these data structures are maintained by the kernel.
The whole system is called iptables, with an iptables user-space command to create and manipulate the rules.

Note: There is a newer system called nftables that has a goal of replacing iptables, but as of this writing, iptables is the dominant system for firewalls.

Because there can be many tables - each with their own sets of chains, each of which can contain many rules - packet flow can become quite complicated.
However, you'll normally work primarily witht a single table named filter that controls basic packet flow.
There are three basic chains in the filter table: INPUT for incoming packets, OUTPUT for outgoing packets, and FORWARD for routed packets.
Figures 9-5 and 9-6 show simplified flowcharts for where rules are applied to packets in the filter table.
There are two figures because packets can either come into the system from a network interface (Figure 9-5) or be generated by a local process (Figure 9-6).
As you can see, an incoming packet from the network can be consumed by a user process and may not reach the FORWARD chain or the OUTPUT chain.
Packets generated by user processes won't reach the INPUT or FORWARD chains.

See page 221

This gets more complicaetd because there are many steps along the way other than just these three chains.
For example, packets are subject to PREROUTING and POSTROUTING chains, and chain processing can also occur at any of the three lower network levels.
For a big diagram for everything that's going on, search the Internet for "Linux netfilter packet flow," but remember that these diagrams try to include every possible scenario for packet input and flow.
It often helps to break the diagrams down by packet source, as in Figures 9-5 and 9-6.

9.21.2 Setting Firewall Rules
Let's look at how the IP tables system works in practice.
Start by viewing the current configuration with this command:

see page 221

Each firewall cahin has a default policy that specifies what to do with a packet if no rule matches the packet.
The policy for all three chains in this example is ACCEPT, meaning that the kernel allows the packet to pass through the packet-filtering system.
The DROP policy tells the kernel to discard the packet.
To set the policy on a chain, use iptables -P like this:

see page 222

Warning
Don't do anything rash with the policies on your machine until you've read through the rest of this section.

Say that someone at 192.168.34.63. is annoying you.
To prevent them from talking to your machine, run this command:

See page 222

The -A INPUT parameter appends a rule to the INPUT chain.
The -s 192.168.34.63. part specifies that source IP address in the rule, and -j DROP tells the kernel to discard any packet matching the rule.
Therefore, your machine will throw out any packet commint from 192.168.34.63.
To see the rule in place, run iptables -L:

see page 222

Unfotunetely, your friend at 192.168.34.63 has told everyone on his subnet to open connections to your SMTP port (TCP port 25).
To get rid of that traffic as well, run

See page 222

This example adds a netmask qualifier to the source address as well as -p tcp to specify TCP packets only.
A further restriction, --destination-port 25, says that the rule should only apply to traffic to port 25.
The IP table list for INPUT now looks like this:

see page 222

All is well until you hear from someone you know at 192.168.34/37 saying that they can't send you email because you blocked their machine.
Thinking that this is a quick fix, you run this command:

However, it doesn't work.
To see why, look at the new chain:

See page 223

The kernel reads the chain from top to bottom, using the first rule that matches.
The first rule does not match 192.168.34.37, but the second does, because it applies to all hosts from 192.168.34.1 to 192.168.34.254 and this second rule says to drop packets.
When a rule matches, the kernel carries out the action and looks no further down in the chain.
(You might notice that 192.168.34.37 can send packets to any port on your machine except port 25 because the second rule only applies to port 25.)
The solution is to move the thrid rule to the top.
First, delete the third rule with this command:

see page 223

Then insert that rule at the top of the chain with iptables -I:


page 223

To insert a rule elsewhere in a chain, put the rule number after the chain name (for example, itables -I INPUT 4 ...).

